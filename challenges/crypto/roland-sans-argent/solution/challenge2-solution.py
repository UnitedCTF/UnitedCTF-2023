from Crypto.Util.number import inverse, long_to_bytes, GCD

# Given parameters from the challenge
n = 114194021424602852676222775460979397798152619390680654104963537621902451831836470362082297540629391019670245824664746208852579273180992066701163543676800651644862472034165286115837997798371540779457218633396524675029078054172857587631842213823984073019202305126609289686879378066041784553293227296464240835267
e1 = 65537
e2 = 65539
ciphertext1 = 28689726464471984025059169318232993078460273209886442537464870355974888638991579001316909915559847253642039942889027715458785887921890991685913066623858066692141396439551507135272690248388212221527918351696136808930939577385332643551868515367824945746400992597126260275260567739704458504887250100888625810473
ciphertext2 = 24634677217736560807813188301324517298313799143930696944427747965369289033302366913857008167212275254432873019849491141635221114106968228983207351990636024265662263907972116273086083369173798015942155844255927609366141240071769784268644137652683967545087600740334041265826459874456456744259034149466527145714

# Extended Euclidean Algorithm to find a and b such that a * e1 + b * e2 = GCD(e1, e2)
def extended_gcd(a, b):
    if a == 0:
        return b, 0, 1
    else:
        g, y, x = extended_gcd(b % a, a)
        return g, x - (b // a) * y, y

# Compute values a and b
gcd, a, b = extended_gcd(e1, e2)
if gcd != 1:
    raise ValueError("e1 and e2 are not coprime!")

# Using the properties of modular arithmetic for the common modulus attack
part1 = pow(ciphertext1, a, n) if a > 0 else inverse(pow(ciphertext1, -a, n), n)
part2 = pow(ciphertext2, b, n) if b > 0 else inverse(pow(ciphertext2, -b, n), n)

# Compute the original message (as an integer)
m = (part1 * part2) % n

# Convert the integer message back into bytes
flag_bytes = long_to_bytes(m)

# Convert the bytes into a string
flag = flag_bytes.decode()

print("Decrypted flag: ", flag)
