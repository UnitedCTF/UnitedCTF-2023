from Crypto.Util.number import inverse, long_to_bytes

# Given parameters from the challenge
n = 118106226504529835290659902652862270441701393010670403198509548446116062754784895631742671553891360108121798535929655210243116833524376067469193671542849954883259855044690013131911919692051474090274864465256877576012025608338155331729238496718446874151099007504701896133602255803379182471499683549826883906919
e = 65537
p = 13190768637976984234302503932008034455266070327745092110641230246745710909943443108764691767934840058779236981577713301202898617832514492510549730373739809
ciphertext = 109182686074643895722088709167365445141191810738607234946970995195565143126326639298491559811626362620220483542471203258202228523397762222029355647206906381060208234693414092826600022194387688047152133633811429546736922384247476585392163233601397539732454039673206946596526550154189673354003367398347349634094

# Calculate q from n and p
q = n // p

# Calculate totient (phi)
phi = (p - 1) * (q - 1)

# Compute the private key exponent (d)
d = inverse(e, phi)

# Decrypt the ciphertext to get the original message (as an integer)
m = pow(ciphertext, d, n)

# Convert the integer message back into bytes
flag_bytes = long_to_bytes(m)

# Convert the bytes into a string
flag = flag_bytes.decode()

print("Decrypted flag: ", flag)
